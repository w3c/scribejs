/* eslint-disable no-underscore-dangle */

'use strict';

/*
*
* TODO:
* - is it necessary to reorganize by pushing the io functions into a separate module?
* - add the new field to the Browserify version, and expand the 'bridge' part to include the action handling
* - documentation
*/

const fs = require('fs');

/**
 * Class to maintain actions.
 *
 * An Action structure is an object, of the following structure:
 *
 * ```
 * "config" : {
 *    url_pattern: <A pattern for the URL-s into the minutes; it may include the patterns %YEAR%, %MONTH%, %DAY%, %DATE%.
 *                  Used to generate the URL-s for the actions into the minutes.>
 * },
 * "actions" {
 *    "<username>" : [{
 *        "url"  : <URL into the minutes of the meeting where the action was raised; this is generated by the script>,
 *        "date" : <Date when the action was raised>,
 *        "id"   : <the fragment ID to be used to generate the final url>,
 *        "action" : <the text of the action>
 *        "open" : <boolean value; currently only 'true' is used, but may be used later to display closed issues>
 *    }]
 * }
 * ```
 *
 */
class ActionList {
    /**
     *
     * @param {Object} actions â€“ initial set of actions of the structure described abov
     */
    constructor(actions) {
        // Lots of check and further action is needed here!!!
        this._actions = actions;
        this._action_list = this._actions.actions;
        this._action_config = this._actions.config;
        this._url = '';
        this._changed = false;
    }

    /**
     * Whether the actions were changed since init
     *
     * @returns {Boolean}
     */
    get changed() { return this._changed; }

    /**
     * Set the date (in ISO format). This method _MUST_ be invoked before any adding a new action. The string
     * is used to resolve the generic URL pattern to generate the right urls for actions.
     *
     * @param {string} date
     */
    set_date(date) {
        this.date = date;
        const [year, month, day] = this.date.split('-');
        this._url = this._action_config.url_pattern
            .replace(/%YEAR%/, year)
            .replace(/%MONTH%/, month)
            .replace(/%DAY%/, day)
            .replace(/%DATE%/, this.date);
    }

    /**
     * Add a new action to the list. If the action is already in the list, then the method returns. (This is important if the
     * minutes are generated several times to refine it, so that actions are not repeated.)
     *
     * @param {string} name - User name for the action
     * @param {string} action - action text
     * @param {string} id - the id (in the minutes) of the action
     */
    add_action(name, action, id) {
        const url = `${this._url}#${id}`;
        const new_action = {
            date : this.date,
            url,
            id,
            action,
            open : true
        };
        if (name in this._action_list) {
            // see if the action has already been recorded
            if (this._action_list[name].find((act) => act.url === url) === undefined) {
                this._action_list[name].push(new_action);
                this._changed = true;
            }
        } else {
            this._action_list[name] = [new_action];
            this._changed = true;
        }
    }

    /**
     * Mainly for debug: return the string representing the list of actions only
     */
    toString() {
        return JSON.stringify(this._action_list, null, 4);
    }

    /**
     * Return a JSON representation of the whole action structure (including `config`), ready to be stored in a file.
     */
    toStore() {
        return JSON.stringify(this._actions, null, 4);
    }
}

/**
 * Get the action list (if any). For the time being only file input is used.
 *
 * @param {object} conf - Overall configuration; the only field that matter here is "conf.actions"
 * @returns {Promise} - a promise containing the nicknames as an object parsed from JSON.
 */
function get_action_list(conf) {
    return new Promise((resolve, reject) => {
        if (conf.actions) {
            // This is a local file. Use an async function to retrieve the file,
            // though a sync function would work just as well
            // However if, at some point, remote access is added, then we have the right
            // structure.
            fs.readFile(conf.actions, 'utf-8', (err, body) => {
                if (err) {
                    reject(new Error(`problem accessing local file ${conf.actions}: ${err}`));
                } else {
                    // Try to parse the content as JSON and, if it works, that is almost
                    // the final result, module turn all the nicknames to lowercase
                    let json_content = {};
                    try {
                        json_content = JSON.parse(body);
                    } catch (parse_err) {
                        throw new Error(`JSON parsing error in ${conf.actions}: ${parse_err}`);
                    }
                    resolve(json_content);
                }
            });
        } else {
            resolve({});
        }
    });
}

/**
 * Store the action list (if any) in a file.
 *
 * @param {object} conf - Overall configuration; the only field that matter here is "conf.actions"
 * @param {ActionList} actions - the data to be stored
 * @returns {Promise} - a promise returning no value per se
 */
function store_action_list(conf, actions) {
    return new Promise((resolve, reject) => {
        if (conf.actions) {
            // This is a local file. Use an async function to retrieve the file,
            // though, I believe, a sync function would work just as well
            // However if, at some point, remote access is added, then we have the right
            // structure.
            // The action of copying is done via a sync function, though. It is simpler...
            try {
                fs.copyFileSync(conf.actions, `${conf.actions}.bak`);
            } catch (err) {
                reject(new Error(`problem copying local file ${conf.actions} for backup: ${err}`));
            }
            fs.writeFile(conf.actions, actions.toStore(), 'utf-8', (err) => {
                if (err) {
                    reject(new Error(`problem writing local file ${conf.actions}: ${err}`));
                } else {
                    resolve();
                }
            });
        } else {
            resolve();
        }
    });
}


module.exports = { ActionList, get_action_list, store_action_list };
